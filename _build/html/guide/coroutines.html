

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>协程 &mdash; Tornado 4.3 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Tornado 4.3 documentation" href="../index.html"/>
        <link rel="up" title="用户手册" href="../guide.html"/>
        <link rel="next" title="Queue 示例 - 一个并发网络爬虫" href="queues.html"/>
        <link rel="prev" title="异步和非阻塞 I/O" href="async.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Tornado
          

          
          </a>

          
            
            
              <div class="version">
                4.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../guide.html">用户手册</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="async.html">异步和非阻塞 I/O</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">协程</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="queues.html"><code class="docutils literal"><span class="pre">Queue</span></code> 示例 - 一个并发网络爬虫</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure.html">Tornado web 应用程序结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="templates.html">模版和 UI</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html">认证与安全</a></li>
<li class="toctree-l2"><a class="reference internal" href="running.html">运行和部署</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../webframework.html">Web 框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../http.html">HTTP 服务器和客户端</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking.html">异步网路</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coroutine.html">协程和并发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../integration.html">整合其它服务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utilities.html">实用工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">问题与解答</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">发布说明</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Tornado</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../guide.html">用户手册</a> &raquo;</li>
      
    <li>协程</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/guide/coroutines.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>协程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Tornado 中推荐用 <strong>协程</strong> 来编写异步代码. 协程使用 Python 中的关键字 <code class="docutils literal"><span class="pre">yield</span></code>
来替代链式回调来实现挂起和继续程序的执行(像在 <a class="reference external" href="http://www.gevent.org">gevent</a> 中使用的轻量级线程合作的方法有时也称作协程,
但是在 Tornado 中所有协程使用异步函数来实现的明确的上下文切换).</p>
<p>协程和异步编程的代码一样简单, 而且不用浪费额外的线程, . 它们还可以减少上下文切换 <a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">让并发更简单</a> .</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">tornado</span> <span class="kn">import</span> <span class="n">gen</span>

<span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">fetch_coroutine</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">http_client</span> <span class="o">=</span> <span class="n">AsyncHTTPClient</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># 在 Python 3.3 之前的版本中, 从生成器函数</span>
    <span class="c1"># 返回一个值是不允许的,你必须用</span>
    <span class="c1">#   raise gen.Return(response.body)</span>
    <span class="c1"># 来代替</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span>
</pre></div>
</div>
<div class="section" id="python-3-5-async-await">
<span id="native-coroutines"></span><h2>Python 3.5: <code class="docutils literal"><span class="pre">async</span></code> 和 <code class="docutils literal"><span class="pre">await</span></code><a class="headerlink" href="#python-3-5-async-await" title="Permalink to this headline">¶</a></h2>
<p>Python 3.5 引入了 <code class="docutils literal"><span class="pre">async</span></code> 和 <code class="docutils literal"><span class="pre">await</span></code> 关键字 (使用了这些关键字的函数通常被叫做
&#8220;native coroutines&#8221; ). 从 Tornado 4.3 开始, 在协程基础上你可以使用这些来代替 <code class="docutils literal"><span class="pre">yield</span></code>.
简单的通过使用 <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span> <span class="pre">foo()</span></code> 来代替 <code class="docutils literal"><span class="pre">&#64;gen.coroutine</span></code> 装饰器, 用 <code class="docutils literal"><span class="pre">await</span></code> 来代替 yield.
文档的剩余部分还是使用 <code class="docutils literal"><span class="pre">yield</span></code> 来兼容旧版本的 Python, 但是 <code class="docutils literal"><span class="pre">async</span></code> 和 <code class="docutils literal"><span class="pre">await</span></code> 在可用时将会运行的更快:</p>
<div class="highlight-python"><div class="highlight"><pre>async def fetch_coroutine(url):
    http_client = AsyncHTTPClient()
    response = await http_client.fetch(url)
    return response.body
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">await</span></code> 关键字并不像 <code class="docutils literal"><span class="pre">yield</span></code> 更加通用.
例如, 在一个基于 <code class="docutils literal"><span class="pre">yield</span></code> 的协程中你可以生成一个列表的 <code class="docutils literal"><span class="pre">Futures</span></code>,
但是在原生的协程中你必须给列表报装 <code class="xref py py-obj docutils literal"><span class="pre">tornado.gen.multi</span></code>.
你也可以使用 <code class="xref py py-obj docutils literal"><span class="pre">tornado.gen.convert_yielded</span></code>
将使用 <code class="docutils literal"><span class="pre">yield</span></code> 的任何东西转换成用 <code class="docutils literal"><span class="pre">await</span></code> 工作的形式.</p>
<p>虽然原生的协程不依赖于某种特定的框架
(例如. 它并没有使用像 <code class="xref py py-obj docutils literal"><span class="pre">tornado.gen.coroutine</span></code> 或者
<a class="reference external" href="https://docs.python.org/3.4/library/asyncio-task.html#asyncio.coroutine" title="(in Python v3.4)"><code class="xref py py-obj docutils literal"><span class="pre">asyncio.coroutine</span></code></a> 装饰器), 不是所有的协程都和其它程序兼容.这里有一个 <em>协程运行器</em>
在第一个协程被调用时进行选择, 然后被所有直接调用 <code class="docutils literal"><span class="pre">await</span></code> 的协程库共享.
Tornado 协程运行器设计时就时多用途且可以接受任何框架的 awaitable 对象.
其它协程运行器可能会有更多的限制(例如, <code class="docutils literal"><span class="pre">asyncio</span></code> 协程运行器不能接收其它框架的协程).
由于这个原因, 我们推荐你使用 Tornado 的协程运行器来兼容任何框架的协程.
在 Tornado 协程运行器中调用一个已经用了asyncio协程运行器的协程,只需要用
<code class="xref py py-obj docutils literal"><span class="pre">tornado.platform.asyncio.to_asyncio_future</span></code> 适配器.</p>
</div>
<div class="section" id="id3">
<h2>他是如何工作的<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>一个含有 <code class="docutils literal"><span class="pre">yield</span></code> 的函数时一个 <strong>生成器</strong> . 所有生成器都是异步的;
调用它时将会返回一个对象而不是将函数运行完成.
<code class="docutils literal"><span class="pre">&#64;gen.coroutine</span></code> 修饰器通过 <code class="docutils literal"><span class="pre">yield</span></code> 表达式通过产生一个 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 对象和生成器进行通信.</p>
<p>这是一个协程装饰器内部循环的额简单版本:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># Simplified inner loop of tornado.gen.Runner</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># send(x) makes the current yield return x.</span>
    <span class="c1"># It returns when the next yield is reached</span>
    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
<p>装饰器从生成器接收一个 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 对象, 等待 (非阻塞的) <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 完成, 然后 &#8220;解开&#8221; <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code>
将结果像 <code class="docutils literal"><span class="pre">yield</span></code> 语句一样返回给生成器. 大多数异步代码从不直接接触到 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 类,
除非 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 立即通过异步函数返回给 <code class="docutils literal"><span class="pre">yield</span></code> 表达式.</p>
</div>
<div class="section" id="id4">
<h2>怎样调用协程<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>协程在一般情况下不抛出异常: 在 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 被生成时将会把异常报装进来.
这意味着正确的调用协程十分的重要, 否则你可能忽略很多错误:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">bad_call</span><span class="p">():</span>
    <span class="c1"># This should raise a ZeroDivisionError, but it won&#39;t because</span>
    <span class="c1"># the coroutine is called incorrectly.</span>
    <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>近乎所有情况中, 任何一个调用协程自身的函数必须时协程, 通过利用关键字 <code class="docutils literal"><span class="pre">yield</span></code> 来调用.
当你在覆盖了父类中的方法, 请查阅文档来判断协程是否被支持 (
文档中应该写到那个方法 &#8220;可能是一个协程&#8221; 或者 &#8220;可能返回一个
<code class="xref py py-obj docutils literal"><span class="pre">Future</span></code>&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">good_call</span><span class="p">():</span>
    <span class="c1"># yield will unwrap the Future returned by divide() and raise</span>
    <span class="c1"># the exception.</span>
    <span class="k">yield</span> <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>有时你并不想等待一个协程的返回值. 在这种情况下我们推荐你使用 <code class="xref py py-obj docutils literal"><span class="pre">IOLoop.spawn_callback</span></code>,
这意味着 <code class="xref py py-obj docutils literal"><span class="pre">IOLoop</span></code> 负责调用. 如果它失败了,
<code class="xref py py-obj docutils literal"><span class="pre">IOLoop</span></code> 会在日志中记录调用栈:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># The IOLoop will catch the exception and print a stack trace in</span>
<span class="c1"># the logs. Note that this doesn&#39;t look like a normal call, since</span>
<span class="c1"># we pass the function object to be called by the IOLoop.</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">spawn_callback</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>最后, 在程序的最顶层, <em>如果 `.IOLoop` 没有正在运行,</em> 你可以启动 <code class="xref py py-obj docutils literal"><span class="pre">IOLoop</span></code>, 运行协程, 然后通过</dt>
<dd><p class="first"><code class="xref py py-obj docutils literal"><span class="pre">IOLoop.run_sync</span></code> 方法来停止 <code class="xref py py-obj docutils literal"><span class="pre">IOLoop</span></code>. 这通常被用来启动面向批处理程序的 <code class="docutils literal"><span class="pre">main</span></code> 函数:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c1"># run_sync() doesn&#39;t take arguments, so we must wrap the</span>
<span class="c1"># call in a lambda.</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">run_sync</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h2>协程模式<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="callbacks">
<h3>结合 callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h3>
<p>为了使用回调来代替 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 与异步代码进行交互, 讲这个调用报装在 <code class="xref py py-obj docutils literal"><span class="pre">Task</span></code> 中.
这将会在你生成的 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 对象中添加一个回调参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">call_task</span><span class="p">():</span>
    <span class="c1"># Note that there are no parens on some_function.</span>
    <span class="c1"># This will be translated by Task into</span>
    <span class="c1">#   some_function(other_args, callback=callback)</span>
    <span class="k">yield</span> <span class="n">gen</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span><span class="n">some_function</span><span class="p">,</span> <span class="n">other_args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>调用阻塞函数<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>在协程中调用阻塞函数的最简单方法时通过使用
<a class="reference external" href="https://docs.python.org/3.4/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="(in Python v3.4)"><code class="xref py py-obj docutils literal"><span class="pre">ThreadPoolExecutor</span></code></a>, 这将返回与协程兼容的
<code class="docutils literal"><span class="pre">Futures</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">thread_pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">call_blocking</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">thread_pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">blocking_func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>并行<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>协程装饰器能识别列表或者字典中的 <code class="docutils literal"><span class="pre">Futures</span></code> ,并且并行等待这些 <code class="docutils literal"><span class="pre">Futures</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">parallel_fetch</span><span class="p">(</span><span class="n">url1</span><span class="p">,</span> <span class="n">url2</span><span class="p">):</span>
    <span class="n">resp1</span><span class="p">,</span> <span class="n">resp2</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span><span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url1</span><span class="p">),</span>
                          <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url2</span><span class="p">)]</span>

<span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">parallel_fetch_many</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">responses</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span><span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="c1"># responses is a list of HTTPResponses in the same order</span>

<span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">parallel_fetch_dict</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">responses</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">{</span><span class="n">url</span><span class="p">:</span> <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">}</span>
    <span class="c1"># responses is a dict {url: HTTPResponse}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>交叉存取技术<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>有时保存一个 <code class="xref py py-obj docutils literal"><span class="pre">Future</span></code> 比立刻yield它更有用, 你可以在等待它之前执行其他操作:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">fetch_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fetch_future</span>
        <span class="k">if</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">fetch_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">()</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>循环<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>因为在Python中无法使用 <code class="docutils literal"><span class="pre">for</span></code> 或者 <code class="docutils literal"><span class="pre">while</span></code> 循环 <code class="docutils literal"><span class="pre">yield</span></code> 迭代器,
并且捕获yield的返回结果.  相反, 你需要将循环和访问结果区分开来,
这是一个 <a class="reference external" href="http://motor.readthedocs.org/en/stable/">Motor</a> 的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">motor</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">motor</span><span class="o">.</span><span class="n">MotorClient</span><span class="p">()</span><span class="o">.</span><span class="n">test</span>

<span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">loop_example</span><span class="p">(</span><span class="n">collection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">find</span><span class="p">()</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">yield</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetch_next</span><span class="p">):</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">next_object</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>在后台运行<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-obj docutils literal"><span class="pre">PeriodicCallback</span></code> 和通常的协程不同. 相反, 协程中
通过使用 <code class="xref py py-obj docutils literal"><span class="pre">tornado.gen.sleep</span></code> 可以包含 <code class="docutils literal"><span class="pre">while</span> <span class="pre">True:</span></code> 循环:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">minute_loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">do_something</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">gen</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Coroutines that loop forever are generally started with</span>
<span class="c1"># spawn_callback().</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">spawn_callback</span><span class="p">(</span><span class="n">minute_loop</span><span class="p">)</span>
</pre></div>
</div>
<p>有时可能会遇到一些复杂的循环. 例如, 上一个循环每 <code class="docutils literal"><span class="pre">60+N</span></code> 秒运行一次,
其中 <code class="docutils literal"><span class="pre">N</span></code> 时 <code class="docutils literal"><span class="pre">do_something()</span></code> 的耗时.为了精确运行 60 秒,使用上面的交叉模式:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">minute_loop2</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>   <span class="c1"># Start the clock.</span>
        <span class="k">yield</span> <span class="n">do_something</span><span class="p">()</span>  <span class="c1"># Run while the clock is ticking.</span>
        <span class="k">yield</span> <span class="n">nxt</span>             <span class="c1"># Wait for the timer to run out.</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="queues.html" class="btn btn-neutral float-right" title="Queue 示例 - 一个并发网络爬虫" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="async.html" class="btn btn-neutral" title="异步和非阻塞 I/O" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2009-2016, The Tornado Authors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>